// Script was generated with | ZEN Scripter #  Author: Excalibur | ver. 4.4| Date :01.30.24| Time: 15:45:21
//  ========================================================================================
//  Special thanks to Batts, noozbar, DoNotAtMe and all community staff 
//  ========================================================================================
//  Very Special thanks to TAYLORDRIFT who helped me a lot with all new staff in this app. 
//  ========================================================================================
//  Credits to noozbar for his basic script : Template script with OLED menu - toggle - editable values - save for 3 profiles 
//  Credits to Batts for all example script for Cronus ZEN device.        
// =========================================================================================
                                              
// =========================================================================================
//   Credits to LegitCloudzzz  for : Polar Antirecoil                                                                            
// =========================================================================================
// =========================================================================================
//   Credits to Sweet Evil 14  for :  Aim Assist                 
// =========================================================================================
//===============================================================
//    BUTTON LAYOUT                                              
//===============================================================
define FIRE_BTN             = PS4_R2;
define ADS_BTN              = PS4_L2;
define SPRINT_BTN           = PS4_L3;
define PRONE_BTN            = PS4_CIRCLE;
define JUMP_BTN             = PS4_CROSS;
define SWITCHWEAPON_BTN     = PS4_TRIANGLE;
define RELOAD_BTN           = PS4_SQUARE;
define MELEE_BTN            = PS4_R3;
define TACTICAL_BTN         = PS4_L1;
define GRANADE_BTN          = PS4_R1;
define UP                   = PS4_UP;
define RIGHT                = PS4_RIGHT;
define DOWN                 = PS4_DOWN;
define LEFT                 = PS4_LEFT;
define RX                   = PS4_RX;
define RY                   = PS4_RY;
define LX                   = PS4_LX;
define LY                   = PS4_LY;
//-------------------------------------------------------------------------------------------
define Blue       =  1;  
define Red        =  2;  
define Green      =  3;  
define Pink       =  4;  
define SkyBlue    =  5;  
define Yellow     =  6;  
define White      =  7;  
define ColorOFF   =  8;  
//--------------------------------------
int polar_ar_val;
int Aim_Boost = 7;
int Aim_Correction = 12;
int VerticalStrength;
int HorizontalStrength;
  define Sampling_Time = 10;         
	define Aim_Perfection_Limit = 30;  
	define POS_Aim_Limit = 70;         
	define NEG_Aim_Limit = -70;        
	define POS_Micro_MVT_Limit = 25;   
	define NEG_Micro_MVT_Limit = -25;  
	int X_Last_Value     = 0;          
	int Y_Last_Value     = 0;          
	int X_Current_Value  = 0;          
	int Y_Current_Value  = 0;          
	int Sampling_Done = FALSE;         
	int spiroide_pulse = 0;            
	int fine_pulse = 0;                
	int Joystick_calibration = FALSE;   
	int RX_Axis_Joystick_calibrate = 0; 
	int RY_Axis_Joystick_calibrate = 0; 
//-------------------------------------------------------------------------------------------
int stick_noise = 5;                                                                         
int i;                                                                                       
int a;                                                                                       
int a1;                                                                                      
int a2;                                                                                      
int ARVal;                                                                                   
int AR_b_max;                                                                                
int b_ARVal = 20;                                                    
//-------------------------------------------------------------------------------------------
data(1,// begin of data segment-------- 
  2,0,0,0, //1. Blue     
  0,2,0,0, //2. Red      
  0,0,2,0, //3. Green    
  0,0,0,2, //4. Pink     
  2,0,2,0, //5. SkyBlue 
  0,2,2,0, //6. Yellow   
  2,2,2,2, //7. White    
  0,0,0,0  //8. Color OFF 
); // end of data segment--------------  
// Refresh OLED              
    int display_title = TRUE;
    int display_black;      
    int refresh_OLED;        
    int ModMenu;    
    int ModEdit;   
    int display_EDIT;   
////////////////////////////////////// 
/////////////////////////////////////// 
int count_black;                      
int need_to_be_save;                 
int BlinckColor = 3;                 
int Col_ind;                         
    //const string TITLE = "My Game"; // 18 char max 
    const string TITLE = " OP AIM "; // 11 char max 
    const string OFF = "OFF";    
    const string ON  = "ON";   
// Index to find Mod Name string - switchable in game with left/right in ModMenu
    int modName_idx;                                                          
// modName # of the last Mod Name string - Used for cycle modName_idx        
   define MAX_MODS_COUNT = 3;                          
// Mod Name      -   Text to Display
  const string POLARANTIRECOIL = "Polar AR" ; 
  const string STICKYAIM       = "Sticky Aim" ; 
  const string AIMASSISTSWEET  = "SweetEvil A" ; 
  const string RUMBLEAR        = "Rumble AR" ; 
//   Toggles 
  int polar_antirecoil_onoff = FALSE ; 
  int sticky_aim_onoff       = FALSE ; 
  int sweet_evil_onoff       = FALSE ; 
  int RumbleAR_toggle        = FALSE ; 
// Mod VALUES      -   Text to Display
const string POLAR_AR_VAL           = "Polar AR" ;
const string AIMBOOST      = "Aim Boost" ;
const string AIMCORRECTION      = "Aim Correct" ;
const string ANTIRECOIL_VERTICAL    = "AR Vertical" ;
const string ANTIRECOIL_HORIZONTAL  = "AR Horizont" ;
// Index to find Value Name string - switchable in game with left/right in ModEdit
    int valName_idx;                  
                                      
    define AMOUNT_OF_VALNAME_IDX = 4; 
// Constant bytes - Convert numbers array - ASCII_NUM[column number] 
    const int8 ASCII_NUM[] =                          
//      0  1  2  3  4  5  6  7  8  9  (column numbers)
      {48,49,50,51,52,53,54,55,56,57};                
                                                   
// Variables for function number_to_string()  
    int s;                            
    int c,c_val;                  
const string NO_EDIT_VAR1  = "No Edit Variables";//  17 
const string NO_EDIT_VAR2  = "for this MOD";// 12       
const byte Options [] = {
  1 , // POLARANTIRECOIL # 1
  0 , // STICKYAIM       # 2
  1 , // AIMASSISTSWEET  # 3
  4 // RUMBLEAR        # 4
};
const byte OptRange [][] = {
  { 0 , 0 }, // POLARANTIRECOIL # 1
  { 0 , 0 }, // STICKYAIM       # 2
  { 1 , 2 }, // AIMASSISTSWEET  # 3
  { 3 , 4 }  // RUMBLEAR        # 4
};
const byte Min_Max_Options [][]={ 
  { 0 , 1 }, // POLARANTIRECOIL # 1
  { 0 , 1 }, // STICKYAIM       # 2
  { 0 , 1 }, // AIMASSISTSWEET  # 3
  { 0 , 4 }  // RUMBLEAR        # 4
}; 
/////////////////////////////////////////////////////////////////////////////  
///   INITIALIZATION BLOCK                                                      
/////////////////////////////////////////////////////////////////////////////   
init {  
polar_antirecoil_onoff = get_pvar(SPVAR_1,0,1,0); 
sticky_aim_onoff       = get_pvar(SPVAR_2,0,1,0); 
sweet_evil_onoff       = get_pvar(SPVAR_3,0,1,0); 
RumbleAR_toggle        = get_pvar(SPVAR_4,0,1,0); 
polar_ar_val        = get_pvar(SPVAR_5, 1,99, 20);
Aim_Boost           = get_pvar(SPVAR_6, 1,30, 7);
Aim_Correction      = get_pvar(SPVAR_7, 1,30, 12);
VerticalStrength    = get_pvar(SPVAR_8, 1,99, 20);
HorizontalStrength  = get_pvar(SPVAR_9,-99,99, 0);
}// end of init block
///////////////////////////////////////////////////////////////////////////// 
///   MAIN BLOCK                                                             
/////////////////////////////////////////////////////////////////////////////
main {//---------------------------------
                                  
   /////////////////////////////////////////
   if(display_EDIT){                
    	 // Clear OLED screen         
       cls_oled(0);                        
       // display_edit(f_idx, f_string, f_print, f_val) 
		if(Options[ modName_idx ] == 0 ){  
			  //--- print label                
		    line_oled(1,45,127,45,1,0);    
		    printf( center_x( 17, OLED_FONT_SMALL_WIDTH ), 20, OLED_FONT_SMALL, 1, NO_EDIT_VAR1[0] ); 
		    printf( center_x( 12, OLED_FONT_SMALL_WIDTH ), 33, OLED_FONT_SMALL, 1, NO_EDIT_VAR2[0] ); 
		}                                                                                            
		else {//----  ELSE BEGIN --------------  
             /////////////////////////////////////////////
             if(valName_idx == 0){ 
                  display_edit(center_x(sizeof(POLAR_AR_VAL          )- 1,OLED_FONT_MEDIUM_WIDTH),POLAR_AR_VAL          [0],polar_ar_val[0]);
                  polar_ar_val = edit_val(polar_ar_val, 0,99);
             }         
             /////////////////////////////////////////////
             if(valName_idx == 1){ 
                  display_edit(center_x(sizeof(AIMBOOST              )- 1,OLED_FONT_MEDIUM_WIDTH),AIMBOOST              [0],Aim_Boost[0]);
                  Aim_Boost = edit_val(Aim_Boost,1,30);
             }         
             /////////////////////////////////////////////
             if(valName_idx == 2){ 
                  display_edit(center_x(sizeof(AIMCORRECTION         )- 1,OLED_FONT_MEDIUM_WIDTH),AIMCORRECTION         [0],Aim_Correction[0]);
                  Aim_Correction = edit_val(Aim_Correction,1,30);
             }         
             /////////////////////////////////////////////
             if(valName_idx == 3){ 
                  display_edit(center_x(sizeof(ANTIRECOIL_VERTICAL   )- 1,OLED_FONT_MEDIUM_WIDTH),ANTIRECOIL_VERTICAL   [0],VerticalStrength[0]);
                  VerticalStrength = edit_val(VerticalStrength, 0,99 );
             }         
             /////////////////////////////////////////////
             if(valName_idx == 4){ 
                  display_edit(center_x(sizeof(ANTIRECOIL_HORIZONTAL )- 1,OLED_FONT_MEDIUM_WIDTH),ANTIRECOIL_HORIZONTAL [0],HorizontalStrength[0]);
                  HorizontalStrength = edit_val(HorizontalStrength,-99,99 );
             }         
		 }//--- ELSE END   ----------- 
   }//  end of display edit  
    if(refresh_OLED)
    { 
        // Clear OLED screen 
        cls_oled(0);       
                           
        line_oled(1,25,127,25,1,1); 
        rect_oled(0, 0,OLED_WIDTH,64,FALSE,1); 
         // Display Value Name and value  
         // Mods that can have different values depending the active Profile 
                                                                                       
         //display_edit( corresponding valName_idx , center_x(sizeof(corresponding_string_to_display) - 1, MEDIUM) , corresponding_string_to_display[0] , val_I_want_to_be_displayed[0] ); 
        // Display Mod Name and togle status  : ON/OFF   
        //display_mod( corresponding modName_idx , center_x(sizeof(corresponding_string_to_display) - 1, OLED_FONT_MEDIUM_WIDTH) , corresponding_string_to_display[0] , toggle_I_want_to_be_displayed[profile]);
        if(modName_idx == 0)display_mod(0, center_x(sizeof(POLARANTIRECOIL)- 1, OLED_FONT_MEDIUM_WIDTH) ,POLARANTIRECOIL[0],polar_antirecoil_onoff,1);
        if(modName_idx == 1)display_mod(1, center_x(sizeof(STICKYAIM      )- 1, OLED_FONT_MEDIUM_WIDTH) ,STICKYAIM      [0],sticky_aim_onoff      ,1);
        if(modName_idx == 2)display_mod(2, center_x(sizeof(AIMASSISTSWEET )- 1, OLED_FONT_MEDIUM_WIDTH) ,AIMASSISTSWEET [0],sweet_evil_onoff      ,1);
        if(modName_idx == 3)display_mod(3, center_x(sizeof(RUMBLEAR       )- 1, OLED_FONT_MEDIUM_WIDTH) ,RUMBLEAR       [0],RumbleAR_toggle       ,29);
              
         refresh_OLED = FALSE; 
    } 
     if(display_title){           
          // clear OLED screen    
    	     cls_oled(0);            
    	     printf(center_x(sizeof(TITLE) - 1, OLED_FONT_MEDIUM_WIDTH),13,OLED_FONT_MEDIUM,OLED_WHITE,TITLE[0]);
	         //printf(center_x(sizeof(TITLE) - 1, OLED_FONT_SMALL_WIDTH),13,OLED_FONT_SMALL,OLED_WHITE,TITLE[0]);
           // screen saver          
	         ModMenu = FALSE;   
           display_title = FALSE;  
           display_black = TRUE;
                                   
    }                            
      
    //-----------------------------
    // Screen saver (OLED off)   
    if(display_black )         
    {                            
        count_black += get_rtime();
        if(count_black >= 5000)   
        {                        
            cls_oled(0);         
            count_black = 0;      
            display_black = FALSE; 
        }                         
    }                           
                                
   /////////////////////////////////////////////////////////
   // MENU EDIT VALUES             
   if(ModEdit){ 
        block_all_inputs(); 
       //--- Exit from EDIT MENU  
       if(event_release(PS4_CIRCLE)){
             ModEdit      = FALSE;           
             display_EDIT = FALSE;           
             ModMenu      = TRUE;            
             refresh_OLED = TRUE;   // display MODS 
       }                    
        ////////////////////////////////////////////////////////////////////////////////  
        //  GO FORWARD                                                                      
        if(!get_val(PS4_L2) && event_press(PS4_DOWN)){            
                                          
        	   valName_idx ++;                 
        	   if(valName_idx > OptRange[ modName_idx ][ 1 ])  valName_idx = OptRange[ modName_idx ][ 1 ]; 
             refresh_OLED = FALSE;      
             display_EDIT = TRUE;        
        }          
        ///////////////////////////////////////////////////////////////////////////////  
        //  GO BACK                                                                      
        if(!get_val(PS4_L2) && event_press(PS4_UP)){  
                                                               
        	   valName_idx --;                                      
        	   if(valName_idx < OptRange[ modName_idx ][ 0 ]) valName_idx = OptRange[ modName_idx ][ 0 ];
             refresh_OLED = FALSE;      
             display_EDIT = TRUE;        
        }                                                           
            /////////////////////////////////////////////////////// 
   }// end of EDIT MENU    
   /////////////////////////////////////////////////////////
   // EDIT MENU ON/OFF            
   if(get_val(PS4_TOUCH) && event_press(PS4_R3)){  
        ModMenu = TRUE;  
        // toggle EditMenu ON/OFF                      
                 modName_idx  = 0;                   
                 refresh_OLED = TRUE;   // display Title    
                 display_EDIT = FALSE;        
   }      
   /////////////////////////////////////////////////////////
   // MENU SYSTEM              
   if(ModMenu){  
        block_all_inputs(); 
      //--- Exit from MENU  
      if(event_press(PS4_CIRCLE)){
          ModMenu = FALSE;                     
          ModEdit = FALSE;              
          combo_run(MESSAGE);             
      }                    
      //--- Enter in EDIT MENU 
      if(event_press(PS4_CROSS)){
          ModMenu     = FALSE;   
          valName_idx = OptRange[ modName_idx ][ 0 ]; 
          ModEdit     = TRUE;   
          display_EDIT= TRUE; 
      }                    
                                  
        //Display MOD NAME and togle status 
        // Switch MODs                     
        if( !get_val(PS4_L2) && event_press(PS4_DOWN)){ 
                                          
        	   modName_idx ++;                 
        	   if(modName_idx > 3) modName_idx = 0; 
          //////////////////////////////////////
        	if(modName_idx == 0 ) { 
        		  blinck( polar_antirecoil_onoff);   
        	}                                    
          /////////////////////////////////////
          //////////////////////////////////////
        	if(modName_idx == 1 ) { 
        		  blinck( sticky_aim_onoff      );   
        	}                                    
          /////////////////////////////////////
          //////////////////////////////////////
        	if(modName_idx == 2 ) { 
        		  blinck( sweet_evil_onoff      );   
        	}                                    
          /////////////////////////////////////
          //////////////////////////////////////
        	if(modName_idx == 3 ) { 
        		  blinck( RumbleAR_toggle       );   
        	}                                    
          /////////////////////////////////////
        }                          
        if(!get_val(PS4_L2) && event_press(PS4_UP)){  
                                                               
        	  modName_idx --;                                      
        	  if(modName_idx < 0) modName_idx = 3;
          //////////////////////////////////////
        	if(modName_idx == 0 ) { 
        		  blinck( polar_antirecoil_onoff);   
        	}                                    
          /////////////////////////////////////
          //////////////////////////////////////
        	if(modName_idx == 1 ) { 
        		  blinck( sticky_aim_onoff      );   
        	}                                    
          /////////////////////////////////////
          //////////////////////////////////////
        	if(modName_idx == 2 ) { 
        		  blinck( sweet_evil_onoff      );   
        	}                                    
          /////////////////////////////////////
          //////////////////////////////////////
        	if(modName_idx == 3 ) { 
        		  blinck( RumbleAR_toggle       );   
        	}                                    
          /////////////////////////////////////
          }                        
        	//////////////////////////
                                  
                                  
        // screen saver           
        display_black = FALSE;    
        display_title = FALSE;    
        //////////////////////////////  
        // display mod name and Toggle ON/OFF | Scroll Options 
        if(!get_val(PS4_L2) ){    
             if(event_press(PS4_CROSS)){ //   go back
                                                  
        	    if(modName_idx == 0 ) { 
                      polar_antirecoil_onoff = f_go_back( polar_antirecoil_onoff ); 
        	    }                                 
                                            
                                                  
        	    if(modName_idx == 1 ) { 
                      sticky_aim_onoff = f_go_back( sticky_aim_onoff ); 
        	    }                                 
                                            
                                                  
        	    if(modName_idx == 2 ) { 
                      sweet_evil_onoff = f_go_back( sweet_evil_onoff ); 
        	    }                                 
                                            
                                                  
        	    if(modName_idx == 3 ) { 
                      RumbleAR_toggle = f_go_back( RumbleAR_toggle ); 
        	    }                                 
                                            
             }// go back 
             if(event_press(PS4_RIGHT)){//   go forward
                                                  
        	    if(modName_idx == 0 ) { 
                      polar_antirecoil_onoff = f_go_forward( polar_antirecoil_onoff);   
        	    }                                 
                                            
                                                  
        	    if(modName_idx == 1 ) { 
                      sticky_aim_onoff = f_go_forward( sticky_aim_onoff);   
        	    }                                 
                                            
                                                  
        	    if(modName_idx == 2 ) { 
                      sweet_evil_onoff = f_go_forward( sweet_evil_onoff);   
        	    }                                 
                                            
                                                  
        	    if(modName_idx == 3 ) { 
                      RumbleAR_toggle = f_go_forward( RumbleAR_toggle);   
        	    }                                 
                                            
             }// go forward 
       } 
       refresh_OLED = TRUE;   
       set_val(PS4_DOWN,0); 
       set_val(PS4_UP,0); 
       set_val(PS4_CROSS,0); 
    } 
    /////////////////////////////////////////////////////////////
    ///    END OF MENU  /////////////////////////////////////////
    /////////////////////////////////////////////////////////////
/* ==============================  Normal Rumble AR ==========================*/

    if(RumbleAR_toggle == 1 || RumbleAR_toggle == 2)  // If Modern Warfare Rumble OR Cold War Rumble Selected \\ 
    {
        if(get_ival(PS4_R2))  // If Press Fire Trigger , Activate Rumble AR \\ 
        {
            if(!get_rumble(RUMBLE_A) || !get_rumble(RUMBLE_B))  // Until Rumble Is Detected , Set the Strength To Maintain Anti-Recoil Until Rumble Detected \\ 
    
                SmartSens(VerticalStrength,PS4_RY);
                
            else
            {
                if(RumbleAR_toggle == 1) // Modern Warfare Rumble Option 
                    SmartRumble = get_rumble(RumbleToUse())
                    
                else if(RumbleAR_toggle == 2)  // Cold War Rumble Option 
                    AntirecoilStrength = get_rumble(RUMBLE_A)/2;
                
            }
            if(AntirecoilStrength > 10 && AntirecoilStrength < 90)  // If Get Rumble \\ // Calculate The Rumble & Vertical Strength Divided By 4 \\
            {
                AntirecoilStrength = VerticalStrength + SmartRumble / 4;
            }     
            if(AntirecoilStrength < 10)   // If NO Rumble Is Detected \\// This Will Act Like Normal Anti-Recoil \\
            {
                SmartSens(VerticalStrength, PS4_RY);
                SmartSens(HorizontalStrength,PS4_RX); 
            }
            else
            {     
                SmartSens(AntirecoilStrength,PS4_RY);  // If Get Rumble \\ //   
                SmartSens(HorizontalStrength,PS4_RX);      
            }
            AntirecoilStrength  = 0;  // Reset Rumble Calculation
            SmartRumble = 0;          // Reset RumbleToUse(); 
        }
    }
/* =========================== POLAR RUMBLE AR ============================*/

    if(RumbleAR_toggle == 3 || RumbleAR_toggle == 4)  // If Modern Warfare Rumble OR Cold War Rumble Selected \\ 
    {
        if(get_ival(PS4_R2))  // If Press Fire Trigger , Activate Rumble AR \\ 
        {
            if(!get_rumble(RUMBLE_A) || !get_rumble(RUMBLE_B))  // Until Rumble Is Detected , Set the Strength To Maintain Anti-Recoil Until Rumble Detected \\ 
    
                SmartSens(VerticalStrength,POLAR_RY);
                
            else
            {
                if(RumbleAR_toggle == 3) // Modern Warfare Rumble Option 
                    SmartRumble = get_rumble(RumbleToUse())
                    
                else if(RumbleAR_toggle == 4)  // Cold War Rumble Option 
                    AntirecoilStrength = get_rumble(RUMBLE_A)/2;
                
            }
            if(AntirecoilStrength > 10 && AntirecoilStrength < 90)  // If Get Rumble \\ // Calculate The Rumble & Vertical Strength Divided By 4 \\
            {
                AntirecoilStrength = VerticalStrength + SmartRumble / 4;
            }     
            if(AntirecoilStrength < 10)   // If NO Rumble Is Detected \\// This Will Act Like Normal Anti-Recoil \\
            {
                SmartSens(VerticalStrength, POLAR_RY);
                SmartSens(HorizontalStrength,POLAR_RX); 
            }
            else
            {     
                SmartSens(AntirecoilStrength,POLAR_RY);  // If Get Rumble \\ //   
                SmartSens(HorizontalStrength,POLAR_RX);      
            }
            AntirecoilStrength  = 0;  // Reset Rumble Calculation
            SmartRumble = 0;          // Reset RumbleToUse(); 
        }
    }

    /////////////////////////////////////////////////
	  // Polar Anti Recoil                                       
    if(polar_antirecoil_onoff){     
                                                       
	       ARVal = b_ARVal + AR_b_max;                           
	       AR_b_max = 0;                                              
	       AR_b_max = AR_b_max + (get_ptime(FIRE_BTN) / 250);  
	       //Deadzone                                                             
	       if(isqrt(pow(get_ival(XB1_RX),2) + pow(get_ival(XB1_RY),2)) < stick_noise){
	           if(abs(get_ival(XB1_RX)) < stick_noise) set_val(XB1_RX,0);       
	           if(abs(get_ival(XB1_RY)) < stick_noise) set_val(XB1_RY,0); 
         }                                                  
         //Anti Recoil                                      
         if(get_ival(FIRE_BTN)){                              
             f_anti_recoil();                               
             if(AR_b_max > 10){                            
                 AR_b_max = 0;                            
             }                                             
             if(event_release(FIRE_BTN)){                    
                 AR_b_max = 0;                         
             }                 
        }  
   }  
    //////////////////////////////////////////////////////// 
    //  STICKY AIM       
    if(sticky_aim_onoff){
          if(get_val(ADS_BTN)) set_val(MELEE_BTN,100);
                  
    }
  if(sweet_evil_onoff){                               
    if(get_val(ADS_BTN)){                             
        if(abs(X_Current_Value) <= POS_Micro_MVT_Limit && abs(Y_Current_Value) <= POS_Micro_MVT_Limit){ 
          if(abs(X_Last_Value - X_Current_Value) < 15){ 
              combo_stop(Aim_Assist_Perfection);       
              Sampling_Done = FALSE;                  
           if(get_val(FIRE_BTN) > 95){                
                combo_stop(Fine_Tune_Aim);            
                fine_pulse = 0;                       
                combo_run(spiroide_Aim_Assit);        
           }                                          
           else{                                      
                combo_stop(spiroide_Aim_Assit);       
                spiroide_pulse = 0;                   
                combo_run(Fine_Tune_Aim);             
             }                                        
            }                                          
        }                                               
        else if(abs(X_Current_Value) <= POS_Aim_Limit && abs(Y_Current_Value) <= POS_Aim_Limit){
            combo_stop(Fine_Tune_Aim);                
            combo_stop(spiroide_Aim_Assit);           
            spiroide_pulse = 0;                       
            fine_pulse = 0;                           
            combo_run(Aim_Assist_Perfection);         
       }                                              
     }                                                
      else {                                          
          combo_stop(Fine_Tune_Aim);                  
          combo_stop(spiroide_Aim_Assit);             
          combo_stop(Aim_Assist_Perfection);          
          spiroide_pulse = 0;                         
          fine_pulse = 0;                      
          Sampling_Done = FALSE;            
     }                             
   }                          
                              
} //  end of main block 
///////////////////////////////////////////////////////////////////////////// 
///   COMBO BLOCK                                                             
/////////////////////////////////////////////////////////////////////////////
                       
int exit_wait = 1500;
combo EXIT {     
	wait(exit_wait);     
	cls_oled(0);    
	ModMenu = FALSE;  
	ModEdit = FALSE;    
	display_EDIT = FALSE; 
	display_title = TRUE; 
}                      
int LED_OnOff;       
int rumble_tipe = RUMBLE_A;
       
//=============================================== 
//            LED BLINK                           
//=============================================== 
combo LED_BLINK {                                 
	colourled(LED_OnOff);                           
	wait(200);                                      
	colourled(ColorOFF);                            
	wait(100);                                      
	colourled(LED_OnOff);                           
	wait(200);                                      
	colourled(ColorOFF);                             
	wait(100);                                      
}                                                 
//=============================================== 
//                 VIBRATE SET_UP                 
//=============================================== 
combo vibrate {                                   
	set_rumble(rumble_tipe, 100);                   
	wait(300);                                       
	reset_rumble();                                 
}                                                 
//===============================================  
//                 RUMBLE_TIPE                     
//===============================================  
function set_rumble_tipe ( val) {                  
	if( val){ rumble_tipe = RUMBLE_A ; LED_OnOff = Green;}  
	else    { rumble_tipe = RUMBLE_B ; LED_OnOff = Red  ;} 
	combo_run(vibrate);                     
	combo_run(LED_BLINK);                   
}                                         
  int b_dblclick;int dblclick_msecs;  
	int dblclick_count;                 
	//int onoff = FALSE;                 
	define time_to_dblclick  = 300;// time in ms for second click to occur 
function double_click (button) {                      
    if (b_dblclick) {                                 
        dblclick_msecs = dblclick_msecs + get_rtime();
        if ( dblclick_msecs > time_to_dblclick ) {    
            dblclick_count = 0;                       
            dblclick_msecs = 0;                       
            b_dblclick = FALSE;                       
        }                                             
    }                                                 
    if (event_release(button) && get_ptime(button) < 250) { 
        if (dblclick_count == 0) {                    
            b_dblclick = TRUE;                        
        } else if (dblclick_count == 1) {             
            dblclick_count = 0;                       
          return 1;                                   
        }                                              
        dblclick_count = dblclick_count + 1;          
    }                                                 
                                                     
    return 0;                                        
}           
function f_go_forward (f_variable) {
    f_variable       +=1;   
    if(f_variable  > Min_Max_Options[modName_idx][1] )f_variable  = Min_Max_Options[modName_idx][1]; // max option
    need_to_be_save = TRUE;       
    blinck( f_variable );
    return f_variable;
}

function f_go_back (f_variable) {
    f_variable       -=1;   
    if(f_variable  < Min_Max_Options[modName_idx][0] )f_variable  = Min_Max_Options[modName_idx][0]; 
    need_to_be_save = TRUE;       
    blinck( f_variable );
    return f_variable;
}
//Anti Recoil                 
function f_anti_recoil() {      
  i = get_val(XB1_RY) + ARVal;     
  a = (ARVal) / 100;                       
  a1 = 1 + (a);                                
  a2 = 1 - (a);                                    
  if(get_ival(XB1_RY) > 0){                            
      i = i * a2 + ARVal - pow(10,2) * (a2 * (a1 - 1));
  } else {                                            
      i = i *  a1 - ARVal * (1 - a2);                 
      }                                               
  set_polar(POLAR_RS,clamp(i, -100, 100),90);        
  return;                                            
}                                                   
//Clamp                                            
function f_clamp(f_val,f_min,f_max) {                 
                                                    
    if(f_val < f_min) return f_min;                
    if(f_val > f_max) return f_max;               
    return f_val;               
}   
combo Aim_Assist_Perfection{         
    X_Last_Value = X_Current_Value    
    Y_Last_Value = Y_Current_Value    
    wait(Sampling_Time);                
    X_Current_Value = get_lval(PS4_RX)- RX_Axis_Joystick_calibrate;  
    Y_Current_Value = get_lval(PS4_RY)- RY_Axis_Joystick_calibrate;  
    if (Sampling_Done == TRUE ){                                    
    Aim_Perfection(X_Last_Value, X_Current_Value, 1, 0, 1, 0 );    
    Aim_Perfection(Y_Last_Value, Y_Current_Value, 1, 0, 0, 1 );}   
    X_Last_Value = X_Current_Value;                                
    Y_Last_Value = Y_Current_Value;                                
    wait(Sampling_Time);                                            
    X_Current_Value = get_lval(PS4_RX)- RX_Axis_Joystick_calibrate; 
    Y_Current_Value = get_lval(PS4_RY)- RX_Axis_Joystick_calibrate; 
    if (Sampling_Done == TRUE ){                                   
    Aim_Perfection(X_Last_Value, X_Current_Value, 0, 1, 1, 0 );  
	  Aim_Perfection(Y_Last_Value, Y_Current_Value, 0, 1, 0, 1 );} 
    Sampling_Done = TRUE;               
    wait(Sampling_Time);                 
}                                        
combo Fine_Tune_Aim {                   
    set_val(PS4_RX,( 15 - fine_pulse));   
    set_val(PS4_LX,(-15 + fine_pulse));  
    wait(Sampling_Time);                 
    wait(Sampling_Time);                
    wait(Sampling_Time);                 
    set_val(PS4_RX,(15 - fine_pulse));  
    set_val(PS4_RY,(10 - fine_pulse));  
    set_val(PS4_LX,(-5 + fine_pulse));  
    wait(Sampling_Time);                
    wait(Sampling_Time);                
    wait(Sampling_Time);                
    set_val(PS4_RY,(10 - fine_pulse));  
    wait(Sampling_Time);                
    wait(Sampling_Time);                
    wait(Sampling_Time);                
    wait(Sampling_Time);                
    set_val(PS4_RX,(-15 + fine_pulse)); 
    set_val(PS4_RY,(10 - fine_pulse));  
    set_val(PS4_LX,( 5 - fine_pulse))    
    wait(Sampling_Time);                
    wait(Sampling_Time)                 
    wait(Sampling_Time)                 
    set_val(PS4_RX,(-15 + fine_pulse)); 
    set_val(PS4_LX,(15 - fine_pulse))   
    wait(Sampling_Time);                
    wait(Sampling_Time);                
    wait(Sampling_Time);                
    set_val(PS4_RX,(-15 + fine_pulse));
    set_val(PS4_RY,(-10 + fine_pulse)); 
    set_val(PS4_LX,(5 - fine_pulse))    
    wait(Sampling_Time);                
    wait(Sampling_Time);                
    wait(Sampling_Time);                
    set_val(PS4_RY,(-10 + fine_pulse)); 
    wait(Sampling_Time);                
    wait(Sampling_Time);                
    wait(Sampling_Time);                
    wait(Sampling_Time);                
    set_val(PS4_RX,(15 - fine_pulse));  
    set_val(PS4_RY,(-10 + fine_pulse)); 
    set_val(PS4_LX,( -5 + fine_pulse))   
    wait(Sampling_Time);               
    wait(Sampling_Time);               
    fine_pulse = fine_pulse + 2;       
    if ( fine_pulse >10){               
    fine_pulse = 0;}                    
}                                       
combo spiroide_Aim_Assit {               
    set_val(PS4_RX,(4 + spiroide_pulse)); 
    set_val(PS4_LX,(-15+ spiroide_pulse)); 
    wait(Sampling_Time);                  
    wait(Sampling_Time);                  
    set_val(PS4_RY,(5 + spiroide_pulse)); 
    wait(Sampling_Time);                  
    wait(Sampling_Time);                   
    wait(Sampling_Time);                   
    wait(Sampling_Time);                   
    set_val(PS4_RX,(-4 - spiroide_pulse)); 
    set_val(PS4_LX,15 - spiroide_pulse );  
    wait(Sampling_Time);                  
    wait(Sampling_Time)                    
    set_val(PS4_RY,(5 + spiroide_pulse));  
    wait(Sampling_Time);                   
    wait(Sampling_Time);                   
    wait(Sampling_Time);                   
    wait(Sampling_Time);                   
	spiroide_pulse = spiroide_pulse + 2;      
	if ( spiroide_pulse >10){                 
	spiroide_pulse = 0;}                      
}                                            
function Aim_Perfection(Last_Value, Current_Value, Boost, Correction, X_AXIS, Y_AXIS ) { 
	if(abs(Last_Value - Current_Value) < Aim_Perfection_Limit){ 
	if(Last_Value < Current_Value){               
	if (Boost){                                   
	if (X_AXIS)                                   
	set_val(PS4_RX, (Current_Value + Aim_Boost));  
	if (Y_AXIS)                                     
	set_val(PS4_RY, (Current_Value + Aim_Boost));}  
	else if(Correction){                             
	if (X_AXIS)                                       
	set_val(PS4_RX, (Current_Value - Aim_Correction));
	if (Y_AXIS)                                         
	set_val(PS4_RY, (Current_Value - Aim_Correction));}}
	else{                                               
	if (Boost){                                         
	if (X_AXIS)                                        
	set_val(PS4_RX, (Current_Value - Aim_Boost));       
	if (Y_AXIS)                                         
	set_val(PS4_RY, (Current_Value - Aim_Boost));}      
	else if(Correction){                                
	if (X_AXIS)                                         
	set_val(PS4_RX, (Current_Value + Aim_Correction));  
	if (Y_AXIS)                                           
	set_val(PS4_RY, (Current_Value + Aim_Correction));}}}
}         
// Variables \\
int SmartRumble,AntirecoilStrength;
int SmartSens_side,SmartSens;
int polar_to_standard;
int final_val;
int range_min;
int range_max;
function RumbleToUse() {
    if(get_rumble(RUMBLE_A) == get_rumble(RUMBLE_B)) 
    {
        return RUMBLE_A;
    }
    if(get_rumble(RUMBLE_A) == 100) 
    {
        return RUMBLE_B;
    }
    if(get_rumble(RUMBLE_B) == 100) 
    {
        return RUMBLE_A;
    }
    if(get_rumble(RUMBLE_A) > get_rumble(RUMBLE_B)) 
    {
        return RUMBLE_A;
    }
    if(get_rumble(RUMBLE_A) < get_rumble(RUMBLE_B)) 
    {
        return RUMBLE_B;
    }
    return 0;
}
function SmartSens(f_val, f_axis) { 
    
    if     (f_axis == POLAR_RX) polar_to_standard = PS4_RX;
    else if(f_axis == POLAR_RY) polar_to_standard = PS4_RY;
    else if(f_axis == POLAR_LX) polar_to_standard = PS4_LX;
    else if(f_axis == POLAR_LY) polar_to_standard = PS4_LY;
    else    polar_to_standard = f_axis;
    
    if(f_val < 0)
        SmartSens_side = -1; // Left / Up 
    else 
        SmartSens_side = 1; // Right / Down 

    if(SmartSens_side == -1) // if f_val has a negative value (Left side or Up) 
    {
        if(get_ival(f_axis) > 0) // if Right stick input has a positive value
            SmartSens = ((get_ival(polar_to_standard) * (100 - f_val)) / 100); 
        
        else if(get_ival(f_axis) <= 0) // if Right stick input has a negative value
            SmartSens = ((get_ival(polar_to_standard) * (100 + f_val)) / 100);
    }
    
    if(SmartSens_side == 1) // if f_val has a positive value (Right side or Down)
    {
        if(get_ival(f_axis) < 0) // if Right stick input has a negative value
            SmartSens = ((get_ival(polar_to_standard) * (100 + f_val)) / 100); 
            
        else if(get_ival(f_axis) >= 0) // if Right stick input has a positive value
            SmartSens = ((get_ival(polar_to_standard) * (100 - f_val)) / 100);
    }
            
    if(polar_to_standard == f_axis)
    {
        final_val = f_val + SmartSens;
        range_min = -100;
        range_max = 100;
    }
    else
    {
        final_val = (f_val + SmartSens) * 327;
        range_min = -32768;
        range_max = 32767;
    }
// Set axis to SmartSens value
    if(SmartSens_side == -1 && get_val(f_axis) >= final_val || SmartSens_side == 1 && get_val(f_axis) <= final_val)
        set_val(f_axis, clamp(final_val, range_min, range_max));
}
define FONT_STATS_INDEX_WIDTH    = 0; 
define FONT_STATS_INDEX_HEIGHT   = 1; 
define FONT_STATS_INDEX_MAXCHARS = 2; 
                                      
                                      
//////////////////////////////////////////////////////////////// 
function horizontal_center_offset(number_characters, font_size) { 
    return (128 - number_characters * FONT_STATS[font_size][FONT_STATS_INDEX_WIDTH]) / 2;
}             
              
const string EXIT_TXT1 = "SETTINGS";  
const string EXIT_TXT2 = "WAS SAVED"; 
                                     
////////////////////////////////////////////////////////////////////////////// 
///  SAVE  
function save_toggles () {  
                    
     set_pvar(SPVAR_1,polar_antirecoil_onoff); 
     set_pvar(SPVAR_2,sticky_aim_onoff      ); 
     set_pvar(SPVAR_3,sweet_evil_onoff      ); 
     set_pvar(SPVAR_4,RumbleAR_toggle       ); 
     set_pvar(SPVAR_5,polar_ar_val); 
     set_pvar(SPVAR_6,Aim_Boost); 
     set_pvar(SPVAR_7,Aim_Correction); 
     set_pvar(SPVAR_8,VerticalStrength); 
     set_pvar(SPVAR_9,HorizontalStrength); 
    combo_run(EXIT);                  
      
}// end of save   
                      
combo MESSAGE {       
    wait(20);         
    save_toggles ();  
    cls_oled(0);      
    printf(horizontal_center_offset(sizeof(EXIT_TXT1), OLED_FONT_MEDIUM ), 2, OLED_FONT_MEDIUM, 1, EXIT_TXT1[0]); 
    printf(horizontal_center_offset(sizeof(EXIT_TXT2), OLED_FONT_MEDIUM ), 23, OLED_FONT_MEDIUM, 1, EXIT_TXT2[0]);
    exit_wait = 2000;     
}                        
function blinck ( var){  
	if(var){               
		BlinckColor = Green;
	}else{                 
		BlinckColor = Red;    
	}                       
	combo_run(BLINK_NOTIFY); 
}                           
                            
combo BLINK_NOTIFY {        
	colourled(BlinckColor);   
	wait(300);                 
	colourled(ColorOFF);        
	wait(100);                  
	colourled(BlinckColor);      
	wait(300);                   
	colourled(ColorOFF);          
}                                
                                
const uint8 FONT_STATS[][] = {  
    {  7, 10, 18 }, // Small    
    { 11, 18, 11 }, // Medium   
    { 16, 26,  7 }  // Large    
};                              
                                
function display_edit( f_string, f_print, f_val) {
    printf(f_string, 0, OLED_FONT_MEDIUM, OLED_WHITE, f_print);  
    number_to_string(f_val, find_digits(f_val));     
}                                                  
function number_to_string(f_val,f_digits) {                  
/*********************************************************** 
 *  number_to_string(value to convert, # of digits in value) 
 *                                                           
 *  Display Up to Max 16-bit Signed Integer (-32,768 to 32,767) 
 *                                                      
 *      Convert digits to ASCII                         
 *      Add ASCII character to print buffer            
 *      Print string centered X & Y on OLED             
*                                                       
***********************************************************/
    s = 1;  c_val = 10000;                            
                                                      
    if(f_val < 0) //--neg numbers                     
    {                                                 
         putc_oled(s,45);    //--add leading "-"      
         s += 1;                                      
         f_val = abs(f_val);                          
    }                                                 
                                                      
    for(c = 5; c >= 1; c--)                           
    {                                                 
        if(f_digits >= c)                             
        {                                             
            putc_oled(s,ASCII_NUM[f_val / c_val]);    
            f_val = f_val % c_val;                    
            s +=  1;                                  
            if(c == 4)                               
            {                                         
                putc_oled(s,44);   //--add ","        
                s += 1;                               
            }                                        
        }                                             
        c_val /= 10;                                  
    }                                                
    puts_oled(center_x(s - 1,OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,s - 1,OLED_WHITE); // adjustable value centered in X 
}                                                     
int n_str_;                  
int horiz_X_center_sufix;    
                             
function print_number(f_val,f_digits ,print_s_x , print_s_y , f_font) { 
                                                      
    n_str_ = 1;  c_val = 10000;                       
                                                      
    if(f_val < 0) //--neg numbers                     
    {                                                 
         putc_oled(n_str_,45);    //--add leading "-" 
         n_str_ += 1;                                 
         f_val = abs(f_val);                          
                                                      
    }                                                 
                                                      
    for(c = 5; c >= 1; c--)                           
    {                                                 
        if(f_digits >= c)                             
        {                                              
            putc_oled(n_str_,ASCII_NUM[f_val / c_val]);
            f_val = f_val % c_val;                    
            n_str_ +=  1;                             
                                                      
        }                                             
        c_val /= 10;                                  
    }                                                 
    puts_oled(print_s_x,print_s_y,f_font,n_str_ - 1,OLED_WHITE); // adjustable value centered in X
}                                                     
                                                      
function edit_val( f_val, f_min, f_max ) {  // antirecoil = edit_val( 0 , antirecoil, 99  , 99  ) 
    line_oled(1,18,127,18,1,1);                                        
    // print the range values                                          
    // on the left: min value                                          
    print_number(f_min ,find_digits(f_min) ,4 , 22 , OLED_FONT_SMALL); 
    // on the right: max value                                         
    print_number(f_max ,find_digits(f_max) ,97 , 22 , OLED_FONT_SMALL);
                                          
    if(get_val(PS4_L2)){                  
		if(press_hold(PS4_RIGHT)){            
			f_val ++;                           
			if(f_val > f_max ) f_val = f_max;   
			display_EDIT = TRUE;                
			need_to_be_save = TRUE;             
		}                                     
                                          
		if(press_hold(PS4_LEFT)){             
			f_val --;                           
			if(f_val < f_min ) f_val = f_min;   
			display_EDIT = TRUE;                
			need_to_be_save = TRUE;             
		}                                     
		if(press_hold(PS4_UP)){               
			f_val +=10;                         
			if(f_val > f_max ) f_val = f_max;   
			display_EDIT = TRUE;                
			need_to_be_save = TRUE;             
		}                                     
                                          
		if(press_hold(PS4_DOWN)){             
			f_val -=10;                         
			if(f_val < f_min ) f_val = f_min;   
			display_EDIT = TRUE;                
			need_to_be_save = TRUE;             
		}                                     
	}                                      
    return f_val;                        
}                                        
                                             
                                   
function press_hold(f_btn) {       
//  return TRUE - event_press()    
//- every 250ms when button is held 
	  return event_press(f_btn) || get_val(f_btn) && get_ptime(f_btn) > 250 
	       && get_ptime(f_btn) % (get_rtime() * 8) == 0;
}               
                
function find_digits(f_num) {                         
//  find_digits(value)                                
//        return Number of Digits in Value Passed     
                                                      
    f_num = abs(f_num);                               
    if(f_num / 10000 > 0) return 5;                   
    if(f_num /  1000 > 0) return 4;                   
    if(f_num /   100 > 0) return 3;                   
    if(f_num /    10 > 0) return 2;                   
                          return 1;                  
}                                                     
///////////////////////////////////////////////
//  FUNCTIONS                                 
                                              
function center_x(f_chars,f_font) {           
//  center_x(number of chars,font size);     
//        return X for Centering String Horizontally 
                                                      
    return (OLED_WIDTH / 2) - ((f_chars * f_font) / 2); 
}                                                      
                                                       
const string ModOption_3_0 = "Disabled"; 
const string ModOption_3_1 = "MW Normal"; 
const string ModOption_3_2 = "CW Normal"; 
const string ModOption_3_3 = "MW Polar"; 
const string ModOption_3_4 = "CW Polar"; 
function display_mod(f_idx, f_string, mod_name, f_toggle, f_option) {   
        // Display MOD_NAME                                    
        printf(f_string, 3, OLED_FONT_MEDIUM, OLED_WHITE, mod_name); 
        if(f_option == 1)                              
        {                                                     
        // Display Disable / Enable                                 
            if(f_toggle == 1)                                                             
                printf(center_x(sizeof(ON)  - 1, OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE, ON[0]);// Enable 
            else                                                                                               
                printf(center_x(sizeof(OFF) - 1, OLED_FONT_LARGE_WIDTH),37,OLED_FONT_LARGE,OLED_WHITE,OFF[0]);// Disable 
        }            
        if(f_option == 29)   
        {                                                     
            if(f_toggle == 0)                                                             
                printf(center_x(sizeof(ModOption_3_0)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_3_0[0]);// Disabled
                                                                                                                           
            if(f_toggle == 1)                                                             
                printf(center_x(sizeof(ModOption_3_1)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_3_1[0]);// MW Normal
                                                                                                                           
            if(f_toggle == 2)                                                             
                printf(center_x(sizeof(ModOption_3_2)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_3_2[0]);// CW Normal
                                                                                                                           
            if(f_toggle == 3)                                                             
                printf(center_x(sizeof(ModOption_3_3)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_3_3[0]);// MW Polar
                                                                                                                           
            if(f_toggle == 4)                                                             
                printf(center_x(sizeof(ModOption_3_4)  - 1, OLED_FONT_MEDIUM_WIDTH),37,OLED_FONT_MEDIUM,OLED_WHITE, ModOption_3_4[0]);// CW Polar
                                                                                                                           
        }            
}                    
                      
// COLOR LED function        
//-------------------------------------------------------------- 
                                       
function colourled(Colour) {         
	Col_ind=(Colour*4)- 3;             
	set_led(LED_1,duint8(Col_ind  ));   
	set_led(LED_2,duint8(Col_ind+ 1));  
	set_led(LED_3,duint8(Col_ind+ 2));  
	set_led(LED_4,duint8(Col_ind+ 3));  
}                                     